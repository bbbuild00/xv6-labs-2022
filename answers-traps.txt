问题1
Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?
通过之前的阅读可知，调用函数时的参数传递使用寄存器 a1, a2 等通用寄存器。
阅读 call.asm 文件的第 45 行。
通过阅读 call.asm 文件中的 main 函数可知，调用 printf 函数时，13 被寄存器 a2 保存。
答案：
a1, a2, a3 等通用寄存器；13 被寄存器 a2 保存。
问题2
Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
通过阅读函数 f 和 g 得知：函数 f 调用函数 g ；函数 g 使传入的参数加 3 后返回。
所以总结来说，函数 f 就是使传入的参数加 3 后返回。考虑到编译器会进行内联优化，这就意味着一些显而易见的，编译时可以计算的数据会在编译时得出结果，而不是进行函数调用。
查看 main 函数可以发现，printf 中包含了一个对 f 的调用。
但是对应的会汇编代码却是直接将 f(8)+1 替换为 12 。这就说明编译器对这个函数调用进行了优化，所以对于 main 函数的汇编代码来说，其并没有调用函数 f 和 g ，而是在运行之前由编译器对其进行了计算。
答案：main 的汇编代码没有调用 f 和 g 函数。编译器对其进行了优化。
问题3
At what address is the function printf located?
通过搜索容易得到 printf 函数的位置。
 
得到其地址在 0x642。
 
答案：0x642
问题4
What value is in the register ra just after the jalr to printf in main?
auipc 和 jalr 的配合，可以跳转到任意 32 位的地址。
 
具体相关命令介绍请看参考链接：reference1, RISC-V unprivileged instructions.
第 49 行，使用 auipc ra,0x0 将当前程序计数器 pc 的值存入 ra 中。
第 50 行，jalr 1554(ra) 跳转到偏移地址 printf 处，也就是 0x642 的位置。
根据 reference1 中的信息，在执行完这句命令之后， 寄存器 ra 的值设置为 pc + 4 ，也就是 return address 返回地址 0x38。
答案：jalr 指令执行完毕之后，ra 的值为 0x38.
问题5
Run the following code.
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?
Here's a description of little- and big-endian and a more whimsical description.
请查看在线 C Compiler 的运行结果 c++ sell，它打印出了 He110 World。
首先，57616 转换为 16 进制为 e110，所以格式化描述符 %x 打印出了它的 16 进制值。
其次，如果在小端（little-endian）处理器中，数据0x00646c72 的高字节存储在内存的高位，那么从内存低位，也就是低字节开始读取，对应的 ASCII 字符为 rld。
如果在 大端（big-endian）处理器中，数据 0x00646c72 的高字节存储在内存的低位，那么从内存低位，也就是高字节开始读取其 ASCII 码为 dlr。
所以如果大端序和小端序输出相同的内容 i ，那么在其为大端序的时候，i 的值应该为 0x726c64，这样才能保证从内存低位读取时的输出为 rld 。
无论 57616 在大端序还是小端序，它的二进制值都为 e110 。大端序和小端序只是改变了多字节数据在内存中的存放方式，并不改变其真正的值的大小，所以 57616 始终打印为二进制 e110 。
关于大小端，参考：CSDN
答案：如果在大端序，i 的值应该为 0x00646c72 才能保证与小端序输出的内容相同。不用该变 57616 的值。
问题6
In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?
printf("x=%d y=%d", 3);
通过之前的章节可知，函数的参数是通过寄存器a1, a2 等来传递。如果 prinf 少传递一个参数，那么其仍会从一个确定的寄存器中读取其想要的参数值，但是我们并没有给出这个确定的参数并将其存储在寄存器中，所以函数将从此寄存器中获取到一个随机的不确定的值作为其参数。故而此例中，y=后面的值我们不能够确定，它是一个垃圾值。
答案：y= 之后的值为一个不确定的垃圾值。
